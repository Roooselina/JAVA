package main;

import java.awt.Rectangle;

import Entity.CommonEntity;

public class CollisionChecker {
	GamePanel gp;

	// CollisionChecker 생성자: GamePanel 객체를 초기화
	public CollisionChecker(GamePanel gp) {
		this.gp = gp;
	}

	// 엔티티의 타일 충돌을 체크하는 메서드
	public void CheckTile(CommonEntity entity) {
	    int entityLeftWorldX = entity.worldX + entity.solidArea.x;
	    int entityRightWorldX = entity.worldX + entity.solidArea.x + entity.solidArea.width;
	    int entityTopWorldY = entity.worldY + entity.solidArea.y;
	    int entityBottomWorldY = entity.worldY + entity.solidArea.y + entity.solidArea.height;

	    int entityLeftCol = entityLeftWorldX / gp.getOrigianlCharacterSize();
	    int entityRightCol = entityRightWorldX / gp.getOrigianlCharacterSize();
	    int entityTopRow = entityTopWorldY / gp.getOrigianlCharacterSize();
	    int entityBottomRow = entityBottomWorldY / gp.getOrigianlCharacterSize();

	    int tileNum1, tileNum2;

	    int maxCol = gp.tileM.mapTileNum[0].length;
	    int maxRow = gp.tileM.mapTileNum.length;

	    switch (entity.direction) {
	        case "up":
	            entityTopRow = (entityTopWorldY - entity.speed) / gp.getOrigianlCharacterSize();
	            if (entityTopRow >= 0) {
	                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];
	                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];
	                if (gp.tileM.tile[tileNum1].collision || gp.tileM.tile[tileNum2].collision) {
	                    entity.collisionOn = true;
	                }
	            }
	            break;
	        case "down":
	            entityBottomRow = (entityBottomWorldY + entity.speed) / gp.getOrigianlCharacterSize();
	            if (entityBottomRow < maxRow) {
	                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];
	                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];
	                if (gp.tileM.tile[tileNum1].collision || gp.tileM.tile[tileNum2].collision) {
	                    entity.collisionOn = true;
	                }
	            }
	            break;
	        case "left":
	            entityLeftCol = (entityLeftWorldX - entity.speed) / gp.getOrigianlCharacterSize();
	            if (entityLeftCol >= 0) {
	                tileNum1 = gp.tileM.mapTileNum[entityLeftCol][entityTopRow];
	                tileNum2 = gp.tileM.mapTileNum[entityLeftCol][entityBottomRow];
	                if (gp.tileM.tile[tileNum1].collision || gp.tileM.tile[tileNum2].collision) {
	                    entity.collisionOn = true;
	                }
	            }
	            break;
	        case "right":
	            entityRightCol = (entityRightWorldX + entity.speed) / gp.getOrigianlCharacterSize();
	            if (entityRightCol < maxCol) {
	                tileNum1 = gp.tileM.mapTileNum[entityRightCol][entityTopRow];
	                tileNum2 = gp.tileM.mapTileNum[entityRightCol][entityBottomRow];
	                if (gp.tileM.tile[tileNum1].collision || gp.tileM.tile[tileNum2].collision) {
	                    entity.collisionOn = true;
	                }
	            }
	            break;
	    }
	}



	public int CheckObject(CommonEntity entity, boolean player) {
		// 반환할 인덱스를 999로 초기화. 충돌이 없으면 999를 반환함.
		int index = 999;

		// 게임 오브젝트 배열을 순회
		for (int i = 0; i < gp.obj.length; i++) {
			if (gp.obj[i] != null) { // 현재 오브젝트가 null이 아닌 경우에만 처리
				if (gp.obj[i].collision == true) {

					// 엔티티의 현재 충돌 영역 좌표 설정
					// entity.worldX/Y는 엔티티의 월드 좌표, solidAreaDefaultX/Y는 기본 충돌 영역 오프셋
					entity.solidArea.x = entity.worldX + entity.solidAreaDefaultX;
					entity.solidArea.y = entity.worldY + entity.solidAreaDefaultY;

					// 오브젝트의 현재 충돌 영역 좌표 설정
					gp.obj[i].solidArea.x = gp.obj[i].worldX + gp.obj[i].solidAreaDefaultX;
					gp.obj[i].solidArea.y = gp.obj[i].worldY + gp.obj[i].solidAreaDefaultY;

					if (gp.obj[i].collision==true) {
						// 엔티티의 방향에 따라 충돌 영역 좌표를 이동
						switch (entity.direction) {

						case "up":
							// 위로 이동 시, 충돌 영역 y 좌표를 속도만큼 감소
							entity.solidArea.y -= entity.speed;
							if (entity.solidArea.intersects(gp.obj[i].solidArea)) {
								if (gp.obj[i].collision == true) {
									entity.collisionOn = true;
								}
								if (player == true) {
									index = i;
								}
							}

							break;
						case "down":
							// 아래로 이동 시, 충돌 영역 y 좌표를 속도만큼 증가
							entity.solidArea.y += entity.speed;
							if (entity.solidArea.intersects(gp.obj[i].solidArea)) {
								if (gp.obj[i].collision == true) {
									entity.collisionOn = true;
								}
								if (player == true) {
									index = i;
								}
							}
							break;
						case "left":
							// 왼쪽으로 이동 시, 충돌 영역 x 좌표를 속도만큼 감소
							entity.solidArea.x -= entity.speed;
							if (entity.solidArea.intersects(gp.obj[i].solidArea)) {
								if (gp.obj[i].collision == true) {
									entity.collisionOn = true;
								}
								if (player == true) {
									index = i;
								}
							}
							break;
						case "right":
							// 오른쪽으로 이동 시, 충돌 영역 x 좌표를 속도만큼 증가
							entity.solidArea.x += entity.speed;
							if (entity.solidArea.intersects(gp.obj[i].solidArea)) {
								if (gp.obj[i].collision == true) {
									entity.collisionOn = true;
								}
								if (player == true) {
									index = i;
								}
							}
							break;
						case "nothing":
							// 아무 방향도 아닌 경우, 아무것도 하지 않음
							break;
						}

						// 엔티티의 이동 후 충돌 영역이 오브젝트의 충돌 영역과 겹치는지 확인
						if (entity.solidArea.intersects(gp.obj[i].solidArea)) {
							if (gp.obj[i].collision) { // 오브젝트가 충돌 가능한 상태인지 확인
								entity.collisionOn = true; // 엔티티의 충돌 상태를 true로 설정
							}
							if (player) { // 만약 엔티티가 플레이어라면
								index = i; // 충돌한 오브젝트의 인덱스를 반환 값으로 설정
							}
						}

						// 충돌 영역을 원래 위치로 복구
						entity.solidArea.x = entity.solidAreaDefaultX;
						entity.solidArea.y = entity.solidAreaDefaultY;
						gp.obj[i].solidArea.x = gp.obj[i].solidAreaDefaultX;
						gp.obj[i].solidArea.y = gp.obj[i].solidAreaDefaultY;
					}
				}
			}
		}
		// 충돌이 발생한 오브젝트의 인덱스를 반환 (충돌이 없으면 999 반환)
		return index;

	}

	public int checkEntity(CommonEntity entity, CommonEntity[] target) {
	    // 반환할 인덱스를 999로 초기화. 충돌이 없으면 999를 반환함.
	    int index = 999;

	    // 엔티티의 현재 충돌 영역 좌표 설정
	    Rectangle entitySolidArea = new Rectangle(entity.worldX - entity.solidArea.x, entity.worldY - entity.solidArea.y, entity.solidArea.width, entity.solidArea.height);
	    
	    // 게임 오브젝트 배열을 순회
	    for (int i = 0; i < target.length; i++) {
	        if (target[i] != null) { // 현재 오브젝트가 null이 아닌 경우에만 처리
	            if (target[i].collisionOn) {
	                // 오브젝트의 현재 충돌 영역 좌표 설정
	                Rectangle targetSolidArea = new Rectangle(target[i].worldX + target[i].solidArea.x, target[i].worldY + target[i].solidArea.y, target[i].solidArea.width, target[i].solidArea.height);

	                // 엔티티의 방향에 따라 충돌 영역 좌표를 이동
	                switch (entity.direction) {
	                    case "up":
	                        entitySolidArea.y -= entity.speed;
	                        if (entity.solidArea.intersects(target[i].solidArea)) {
	                            index = i;
	                        }
	                        break;
	                    case "down":
	                        entitySolidArea.y += entity.speed;
	                        if (entity.solidArea.intersects(target[i].solidArea)) {
	                            index = i;
	                        }
	                        break;
	                    case "left":
	                        entitySolidArea.x += entity.speed;
	                        if (entity.solidArea.intersects(target[i].solidArea)) {
	                            index = i;
	                        }
	                        break;
	                    case "right":
	                        entitySolidArea.x -= entity.speed;
	                        if (entity.solidArea.intersects(target[i].solidArea)) {
	                            index = i;
	                        }
	                        break;
	                }

	                // 충돌 영역을 원래 위치로 복구
	                entity.solidArea.x = entity.solidAreaDefaultX;
	                entity.solidArea.y = entity.solidAreaDefaultY;
	                target[i].solidArea.x = target[i].solidAreaDefaultX;
	                target[i].solidArea.y = target[i].solidAreaDefaultY;
	                
	                
	                if (index != 999) {
	                    entity.collisionOn = true; // 충돌 상태 설정
	                    break; // 충돌이 발생하면 루프 탈출
	                }
	            }
	        }
	    }

	    // 충돌이 발생한 오브젝트의 인덱스를 반환 (충돌이 없으면 999 반환)
	    return index;
	}


	public void checkPlayer(CommonEntity entity) {
		if (gp.player.collisionOn == true) {

			// 엔티티의 현재 충돌 영역 좌표 설정
			// entity.worldX/Y는 엔티티의 월드 좌표, solidAreaDefaultX/Y는 기본 충돌 영역 오프셋
			entity.solidArea.x = entity.worldX + entity.solidAreaDefaultX;
			entity.solidArea.y = entity.worldY + entity.solidAreaDefaultY;

			// 오브젝트의 현재 충돌 영역 좌표 설정
			gp.player.solidArea.x =gp.player.worldX + gp.player.solidAreaDefaultX;
			gp.player.solidArea.y = gp.player.worldY + gp.player.solidAreaDefaultY;

			if (gp.player.collisionOn == true) {
				// 엔티티의 방향에 따라 충돌 영역 좌표를 이동
				switch (entity.direction) {

				case "up":
					// 위로 이동 시, 충돌 영역 y 좌표를 속도만큼 감소
					entity.solidArea.y -= entity.speed;
					if (entity.solidArea.intersects(gp.player.solidArea)) {
						entity.collisionOn = true;
					}

					break;
				case "down":
					// 아래로 이동 시, 충돌 영역 y 좌표를 속도만큼 증가
					entity.solidArea.y += entity.speed;
					if (entity.solidArea.intersects(gp.player.solidArea)) {
						entity.collisionOn = true;

					}
					break;
				case "left":
					// 왼쪽으로 이동 시, 충돌 영역 x 좌표를 속도만큼 감소
					entity.solidArea.x -= entity.speed;
					if (entity.solidArea.intersects(gp.player.solidArea)) {
						entity.collisionOn = true;

					}
					break;
				case "right":
					// 오른쪽으로 이동 시, 충돌 영역 x 좌표를 속도만큼 증가
					entity.solidArea.x += entity.speed;
					if (entity.solidArea.intersects(gp.player.solidArea)) {
						entity.collisionOn = true;
					}
					break;
				case "nothing":
					// 아무 방향도 아닌 경우, 아무것도 하지 않음
					break;
				}

				// 엔티티의 이동 후 충돌 영역이 오브젝트의 충돌 영역과 겹치는지 확인
				if (entity.solidArea.intersects(gp.player.solidArea)) {
					entity.collisionOn = true; // 엔티티의 충돌 상태를 true로 설정

				}

				// 충돌 영역을 원래 위치로 복구
				entity.solidArea.x = entity.solidAreaDefaultX;
				entity.solidArea.y = entity.solidAreaDefaultY;
				gp.player.solidArea.x = gp.player.solidAreaDefaultX;
				gp.player.solidArea.y = gp.player.solidAreaDefaultY;
			}
		}

	}

}
