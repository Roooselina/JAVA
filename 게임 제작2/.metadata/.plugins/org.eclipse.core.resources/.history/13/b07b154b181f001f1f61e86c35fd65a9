package main;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

import javax.swing.JPanel;

import Entity.CommonEntity;
import Entity.Player;
import Object.SuperObjects;
import Tile.TileManager;

public class GamePanel extends JPanel implements Runnable {

	// SCREEN SETTING
	Font font = new Font("빛의 계승자 Bold", Font.BOLD, 30); // 게임에서 사용할 폰트 설정

	final int origianlCharacterSize = 50; // 각 캐릭터의 기본 크기 (픽셀)
	final int maxScreenCol = 5; // 화면의 최대 열 수
	final int maxScreenRow = 5;
	
	int killedMonster = 0;
	int screenX = 0;
	int screenY = 0;
	
	int result; //배틀 결과 저장
	/**
	 * 계획을 변경해서 캐릭터가 움직이지 않고, 배경이 움직일 수 있도록 하겠다.
	 * 
	 */

			
			
	public int getOrigianlCharacterSize() {
		return origianlCharacterSize;
	}

	public int getMaxScreenCol() {
		return maxScreenCol;
	}

	public int getMaxScreenRow() {
		return maxScreenRow;
	}

	public int getMaxWorldCol() {
		return maxWorldCol;
	}

	public int getMaxWorldRow() {
		return maxWorldRow;
	}

	public final int screenWidth = maxScreenCol * origianlCharacterSize; // 1200 - 화면의 가로 길이 (픽셀)
	public final int screenHeight = maxScreenRow * origianlCharacterSize; // 750 - 화면의 세로 길이 (픽셀)

	public final int maxWorldCol = 38;
	public final int maxWorldRow = 30;
	public final int worldWidth = getOrigianlCharacterSize() * maxWorldCol;
	public final int worldHeight = getOrigianlCharacterSize() * maxWorldRow;

	// 키 핸들러
	KeyHandler keyH = new KeyHandler(this);

	// 충돌 감지 인스턴스
	public CollisionChecker cChecker = new CollisionChecker(this);

	// 게임 플레이어 인스턴스
	public Player player = new Player(this, keyH);

	// 타일 관리자
	public TileManager tileM = new TileManager(this);

	
	// 오브젝트(상자 같은 것들) 관리자
	public SuperObjects obj[] = new SuperObjects[100];
	// 오브젝트를 맵에 표시하는 관리자
	ObjectSetter objectSetter = new ObjectSetter(this);
	
	//몬스터 관리자
	public ArrayList<CommonEntity> monster = new ArrayList<CommonEntity>();
	

	// 음악 관리자
	Sound sound = new Sound();

	// 게임 텍스트 메시지 팝업 폰트 관리자
	public UI ui = new UI(this);

	// 게임 루프를 실행하기 위한 스레드
	Thread gameThread;

	//게임 이벤트 처리 관리자
	public EventHandler eHandler = new EventHandler(this);
	
	//캐릭터 그리기 관리자
	SuperPlayerImg playerImages = new SuperPlayerImg();
	
	//배틀 관리자
	MonsterBattle battleManager = new MonsterBattle(this);
	
	// 게임 상태 확인 변수
	public int gameState;
	public final int titleState = 0;
	public final int ScriptState = 1;
	public final int playState = 2;
	public final int pauseState = 3;
	public final int startMonologue = 4;
	public final int dialogueState=5;
	public final int battleState = 6;
	public final int endState = 7;

	/**
	 * 스레드 : 여러 스레드를 사용하여 프로그램의 여러 부분을 동시에 실행[멀티 태스킹] 게임 루프와 같이 주기적으로 업데이트가 필요한 작업을
	 * 수행 여기서는 게임 상태 업데이트에 사용할 예정
	 **/

	public GamePanel() {
		this.setPreferredSize(new Dimension(screenWidth, screenHeight)); // 패널의 크기를 설정
		this.setBackground(Color.BLACK); // 배경색을 검정색으로 설정
		this.setDoubleBuffered(true); // 더블 버퍼링을 활성화하여 그래픽의 깜빡임을 줄이고 부드럽게 렌더링되도록 설정
		this.addKeyListener(keyH); // 키 입력을 처리해줄 핸들러 추가
		this.setFocusable(true); // 패널이 키 입력을 받을 수 있도록 설정
	}

	public void setupGame() {
		// 게임 오브젝트, NPC 및 몬스터 설정
		objectSetter.setObject();
		objectSetter.setMonster();

		// 배경 음악 재생
		playMusic(1);

		// 게임 상태를 타이틀 상태로 설정
		gameState = titleState;

		// 게임 상태에 따라 화면 크기 설정
		adjustScreenSize();
	}

	// 화면 크기를 조절하는 메서드
	public void adjustScreenSize() {
		if (gameState == titleState) {
			int titleWidth = 800;
			int titleHeight = 600;
			GameScreen.window.setSize(titleWidth, titleHeight);
			GameScreen.window.setLocationRelativeTo(null); // 화면 가운데로 위치
		} else if (gameState == playState) {
			GameScreen.window.setSize(screenWidth, screenHeight);
			GameScreen.window.setLocation(50, 0); // 절대 위치 (50, 0)로 설정
		} else if (gameState == dialogueState || gameState == this.endState) {
			screenX =GameScreen.window.getX();
			screenY =GameScreen.window.getY();
			int dialogueWidth = 800;
			int dialogueHeight = 600;
			GameScreen.window.setSize(dialogueWidth, dialogueHeight);
			GameScreen.window.setLocationRelativeTo(null); // 화면 가운데로 위치
		} else if (gameState == gameState) {
			screenX =GameScreen.window.getX();
			screenY =GameScreen.window.getY()-50;
			int dialogueWidth = 800;
			int dialogueHeight = 600;
			GameScreen.window.setSize(dialogueWidth, dialogueHeight);
		}
		
	}

	public void startGameThread() {
		gameThread = new Thread(this); // 새로운 스레드를 생성하여 현재 객체(this)를 Runnable로 전달
		gameThread.start(); // 스레드 시작
	}

	@Override
	public void run() {
		while (gameThread != null) {

			int FPS = 60;
			double drawInterval = 1000000000 / FPS; // 0.0166 sec
			double nextDrawTime = System.nanoTime() + drawInterval; // 1 FPS를 쉬고 나서 그림

			/**
			 * long currentTime = System.nanoTime(); long currentTime2 =
			 * System.currentTimeMillis();
			 * 
			 * currentTime이 훨씬 정확하다.
			 * 
			 * System.nanoTime()은 현재 시간을 나노초 단위로 측정하여 반환 매우 짧은 시간 간격을 측정하는 데 적합함 EX) 성능 테스트나
			 * 애니메이션 프레임 계산 등
			 *
			 * 반면에 System.currentTimeMillis()는 현재 시간을 밀리초 단위로 측정하여 반환 시스템 시계 (epoch time)와
			 * 연관되어 있으며, 일반적으로 이벤트 타임스탬프, 로깅, 시간 간격이 비교적 길 때 사용
			 * 
			 * System.nanoTime()은 매우 짧은 시간 간격을 측정할 때 더 정확도가 높다 System.currentTimeMillis()는
			 * 시스템 시계의 시간을 필요로 하는 경우에 적합
			 */

			// 1 게임 업데이트
			update();

			/**
			 * 중간에 쉬어주지 않으면 컴포넌트가 cpu 연산 속도번 만큼 움직인다.ㅈ FPS를 설정해준다.
			 **/

			// 2 다시 그리기
			repaint();

			try {

				double remainTime = nextDrawTime - System.nanoTime();
				/**
				 * nextDrawTime과 현재 시간(System.nanoTime())의 차이를 계산 다음 프레임을 그리기까지 남은 시간을 나노초 단위로
				 * 나타냄
				 **/

				remainTime = remainTime / 1000000; // 단위 변환 (나노초 -> 밀리초)
				/**
				 * remainTime은 나노초 단위로 계산되었기 때문에, 이를 밀리초 단위로 변환 Thread.sleep 메서드는 매개변수로 밀리초 단위를
				 * 사용하기 때문에 단위 변환이 필요 나노초를 밀리초로 변환하기 위해 1,000,000으로 나눔 (1 밀리초 = 1,000,000 나노초).
				 **/

				if (remainTime < 0)
					remainTime = 0;
				/**
				 * 만약 remainTime이 음수라면, 이는 nextDrawTime이 이미 지난 상태 이 경우 대기 시간을 0으로 설정
				 **/

				Thread.sleep((long) remainTime);
				// 스레드는 remainTime 밀리초 동안 일시 중지

				nextDrawTime += drawInterval;
				// 시간이 지났으니 다시 설정해줌

			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();

				/**
				 * 반드시 try catch문을 사용해야 하는 이유: Thread.sleep 메서드는 지정된 시간 동안 현재 스레드를 일시 중지(sleep)
				 * 역할을 함 이 메서드는 InterruptedException을 발생시킬 수 있음
				 * 
				 * ex. 제대로 된 값 넘어오지 않음, 단위 이상함
				 **/
			}

		}
	}
	
	public void update() {
	    // 게임 상태가 플레이 상태일 때
	    if (gameState == playState) {
	        // 플레이어 업데이트
	        player.update();

	        // 모든 몬스터 업데이트
	        for (int i = 0; i < monster.size(); i++) {
	            if (monster.get(i) != null) {
	                monster.get(i).update();
	                // 플레이어와 몬스터 간의 충돌 검사
	                int monsterCheckIndex = cChecker.checkEntity(player, monster.get(i));
	                // 전투 상태 처리 메서드 호출
	                handleBattleState(monsterCheckIndex, i); // 인덱스를 전달
	            }
	        }
	    } else if (gameState == pauseState) {
	        // 일시정지 상태일 때는 아무 것도 하지 않음
	    }
	}
	/**
	 * update() 메서드:
	
		기능: 게임의 상태를 업데이트
		상세 설명: 게임이 플레이 상태일 때 플레이어와 모든 몬스터의 상태를 업데이트 각 몬스터와 플레이어 간의 충돌 여부를 검사하여 충돌 시 전투 상태로 전환
	 **/
	

	// 충돌 인덱스와 몬스터 인덱스를 받아 전투 상태를 처리하는 메서드
	public void handleBattleState(int collisionIndex, int monsterIndex) {
	    if (collisionIndex != 999) {
	        gameState = battleState; // 게임 상태를 전투 상태로 전환
	        this.stopMusic(); // 현재 재생 중인 음악 정지
	        this.playMusic(4); // 전투 음악 재생

	        // 전투 로직 실행
	        BufferedImage bufferedImage = new BufferedImage(screenWidth, screenHeight, BufferedImage.TYPE_INT_ARGB);
	        Graphics2D g2 = bufferedImage.createGraphics();
	        ui.monsterName = monsterIndex; // 전투 UI에 몬스터 이름 설정

	        // 전투 매니저를 통해 전투 실행
	        battleManager.Battle(monster.get(monsterIndex), g2);
	        g2.dispose(); // Graphics2D 객체 해제
	    }
	}
	
	/**
	 * handleBattleState(int collisionIndex, int monsterIndex) 메서드"
	
		기능: 충돌 발생 시 전투 상태로 전환하고 전투를 처리
		상세 설명: 충돌이 발생하면 게임 상태를 전투 상태로 전환하고, 현재 재생 중인 음악을 정지한 후 전투 음악을 재생/ 그래픽 객체를 사용하여 전투 매니저를 통해 전투를 실행
	 **/
	

	// 게임 화면을 그리는 메서드
	public void paintComponent(Graphics g) {
	    super.paintComponent(g);
	    Graphics2D g2 = (Graphics2D) g;

	    if (gameState == titleState) {
	        // 타이틀 상태일 때 UI 그리기
	        ui.draw(g2);
	    } else if (gameState == ScriptState) {
	        // 스크립트 상태일 때 UI 그리기
	        ui.draw(g2);
	    } else {
	        // 타일 그리기
	        tileM.draw(g2);

	        // 오브젝트 그리기
	        for (int i = 0; i < obj.length; i++) {
	            if (obj[i] != null)
	                obj[i].draw(g2, this);
	        }

	        // 몬스터 그리기
	        for (int i = 0; i < monster.size(); i++) {
	            if (monster.get(i) != null)
	                monster.get(i).draw(g2);
	        }

	        // 플레이어 그리기
	        player.draw(g2);

	        // 투명도 50% 검정색 사각형 그리기
	        g2.setColor(new Color(0, 0, 0, 128)); // 검정색 (RGB: 0, 0, 0), 투명도 50%
	        g2.fillRect(0, 0, getWidth(), getHeight()); // 패널 전체를 채우는 사각형 그리기

	        // UI 그리기
	        ui.draw(g2);

	        // 일시정지 UI 그리기 (PAUSE 메시지)
	        ui.drawPause(g2); // PAUSE 메시지는 잘 보여야 하므로 사각형 이후에 그린다.

	        g2.dispose(); // Graphics2D 객체 해제
	    }
	}

	// 음악을 재생하는 메서드
	public void playMusic(int i) {
	    sound.setFile(i); // 사운드 파일 설정
	    sound.play(); // 음악 재생
	    sound.loop(); // 음악 반복 재생
	}

	// 음악을 정지하는 메서드
	public void stopMusic() {
	    sound.stop(); // 음악 정지
	}

	// 사운드 효과를 재생하는 메서드
	public void playSE(int i) {
	    sound.setFile(i); // 사운드 파일 설정
	    sound.play(); // 사운드 재생
	}
}