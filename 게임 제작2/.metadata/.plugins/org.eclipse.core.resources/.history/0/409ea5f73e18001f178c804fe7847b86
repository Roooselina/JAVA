package main;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;

import javax.swing.JPanel;

import Entity.Player;
import Tile.TileManager;
import Tile.TileRead;

public class GamePanel extends JPanel implements Runnable{

	//SCREEN SETTING
	Font font = new Font("빛의 계승자 Bold", Font.BOLD, 30); // 게임에서 사용할 폰트 설정

	final int origianlCharacterSize = 50; // 각 캐릭터의 기본 크기 (픽셀)
	final int maxScreenCol = 20; // 화면의 최대 열 수
	final int maxScreenLow = 20; // 화면의 최대 행 수
	
	/**
	 * 계획을 변경해서 캐릭터가 움직이지 않고, 배경이 움직일 수 있도록 하겠다.
	 * 
	 * */
	
	public int getOrigianlCharacterSize() {
		return origianlCharacterSize;
	}

	public int getMaxScreenCol() {
		return maxScreenCol;
	}

	public int getMaxScreenLow() {
		return maxScreenLow;
	}

	public int getMaxWorldCol() {
		return maxWorldCol;
	}

	public int getMaxWorldRow() {
		return maxWorldRow;
	}

	public final int screenWidth = maxScreenCol * origianlCharacterSize; // 1200 - 화면의 가로 길이 (픽셀)
	public final int screenHeight = maxScreenLow * origianlCharacterSize; // 750 - 화면의 세로 길이 (픽셀)
	
	
	public final int maxWorldCol = 50;
	public final int maxWorldRow = 50;
	public final int worldWidth = getOrigianlCharacterSize()*maxWorldCol;
	public final int worldHeight = getOrigianlCharacterSize()*maxWorldRow;
	
	
	
	TileRead tileReader = new TileRead(this);
	
	//키 핸들러
	KeyHandler keyH = new KeyHandler();
	
	// 게임 루프를 실행하기 위한 스레드
	Thread gameThread;
	
	/**
	 * 스레드 :  여러 스레드를 사용하여 프로그램의 여러 부분을 동시에 실행[멀티 태스킹]
	 * 게임 루프와 같이 주기적으로 업데이트가 필요한 작업을 수행
	 * 여기서는 게임 상태 업데이트에 사용할 예정
	 **/
	
	//게임 플레이어 인스턴스
	public Player player = new Player(this, keyH);
	
	TileManager tileM = new TileManager(this);

	
	public GamePanel() {
	    this.setPreferredSize(new Dimension(screenWidth, screenHeight)); // 패널의 크기를 설정
	    this.setBackground(Color.BLACK);    // 배경색을 검정색으로 설정
	    this.setDoubleBuffered(true);       // 더블 버퍼링을 활성화하여 그래픽의 깜빡임을 줄이고 부드럽게 렌더링되도록 설정
	    this.addKeyListener(keyH);          // 키 입력을 처리해줄 핸들러 추가
	    this.setFocusable(true);            // 패널이 키 입력을 받을 수 있도록 설정
	}

	public void startGameThread() {
	    gameThread = new Thread(this); // 새로운 스레드를 생성하여 현재 객체(this)를 Runnable로 전달
	    gameThread.start(); // 스레드 시작
	}

	
	@Override
	public void run() {
		while(gameThread != null) {
			
			int FPS = 60;
			double drawInterval = 1000000000/FPS;	//0.0166 sec
			double nextDrawTime = System.nanoTime()+drawInterval; //1 FPS를 쉬고 나서 그림

			/** 
			 * 	long currentTime = System.nanoTime();
			 * long currentTime2 = System.currentTimeMillis();
			 * 
			 * currentTime이 훨씬 정확하다.
			 * 
			 * System.nanoTime()은 현재 시간을 나노초 단위로 측정하여 반환
			 * 매우 짧은 시간 간격을 측정하는 데 적합함 
			 * EX) 성능 테스트나 애니메이션 프레임 계산 등
			 *
			 * 반면에 System.currentTimeMillis()는 현재 시간을 밀리초 단위로 측정하여 반환
			 * 시스템 시계 (epoch time)와 연관되어 있으며, 일반적으로 이벤트 타임스탬프, 로깅, 시간 간격이 비교적 길 때 사용
			 * 
			 * System.nanoTime()은 매우 짧은 시간 간격을 측정할 때 더 정확도가 높다
			 * System.currentTimeMillis()는 시스템 시계의 시간을 필요로 하는 경우에 적합
			 */

			
		
			// 1 게임 업데이트
			update();
			
			/**
			 * 중간에 쉬어주지 않으면 컴포넌트가 cpu 연산 속도번 만큼 움직인다.ㅈ
			 * FPS를 설정해준다.
			**/
			
			// 2 다시 그리기
			repaint();
			
			try {
				
				double remainTime = nextDrawTime-System.nanoTime();
				/**nextDrawTime과 현재 시간(System.nanoTime())의 차이를 계산
				다음 프레임을 그리기까지 남은 시간을 나노초 단위로 나타냄
				**/
				
				remainTime = remainTime/1000000;	// 단위 변환 (나노초 -> 밀리초)
				/**remainTime은 나노초 단위로 계산되었기 때문에, 이를 밀리초 단위로 변환
				Thread.sleep 메서드는 매개변수로 밀리초 단위를 사용하기 때문에 단위 변환이 필요
				나노초를 밀리초로 변환하기 위해 1,000,000으로 나눔 (1 밀리초 = 1,000,000 나노초). 
				 **/
				
				
				if (remainTime < 0)
					remainTime = 0;
				/**
				 * 만약 remainTime이 음수라면, 이는 nextDrawTime이 이미 지난 상태
				 * 이 경우 대기 시간을 0으로 설정
				 **/
				
				Thread.sleep((long)remainTime);
				//스레드는 remainTime 밀리초 동안 일시 중지
				
				nextDrawTime += drawInterval;
				//시간이 지났으니 다시 설정해줌
				
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				
				/**
				 * 반드시 try catch문을 사용해야 하는 이유:
				 * Thread.sleep 메서드는 지정된 시간 동안 현재 스레드를 일시 중지(sleep) 역할을 함
				 * 이 메서드는 InterruptedException을 발생시킬 수 있음
				 * 
				 * ex. 제대로 된 값 넘어오지 않음, 단위 이상함
				 **/
			}
			
		}		
	}
	
	public void update() {
		player.update();
	}
	
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		Graphics2D g2 = (Graphics2D) g;
		
		tileM.draw(g2);
		player.draw(g2);
		

		/**
		 * 캐릭터를 먼저 그릴 경우, 캐릭터가 가려짐 주의
		 * **/
		
		g2.dispose();
	}
}
